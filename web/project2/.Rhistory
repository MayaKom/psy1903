congruent_mean = behavior["congruent_mean"],
incongruent_mean = behavior["incongruent_mean"],
congruent_accuracy = behavior["congruent_accuracy"],
incongruent_accuracy = behavior["incongruent_accuracy"],
d_score = behavior["d_score"],
row.names = NULL
)
## Save summary CSV to cleaned/participants
write.csv(
df_clean,
here::here("data", "cleaned", "participants", paste0(subject_id, "_cleaned.csv")),
row.names = FALSE
)
#### Return output -----------------------------------------------------------
stopifnot(nrow(df_clean) == 1)  # one row per participant
return(df_clean)
}
build_participant_wide <- function() {
files <- list.files(
here::here("data", "raw"),
pattern = "sub-.*\\.csv$",
full.names = FALSE
)
# Bug 1. changed full.names to FALSE so that we don't store the entire file paths as names
## If you see an error "cannot open the connection", it usually means that R cannot find something where it's looking. Check your paths, files, and file_name. Remember where file_name comes from.
if (length(files) == 0L) stop("No CSV files found in data/raw")
rows <- list()
for (i in seq_along(files)) {
file_name <- files[i]
rows[[i]] <- import_and_process(file_name)
}
out  <- do.call(rbind, rows)
rownames(out) <- NULL
return(out)
}
participant_wide <- build_participant_wide()
import_and_process <- function(file_name) {
#### Read participant CSV ----------------------------------------------------
df <- read.csv(
here::here("data", "raw", file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
## If you see an error "cannot open the connection", it usually means that R cannot find something where it's looking. Check your paths, files, and file_name. Remember where file_name comes from.
#### Check expected columns ----------------------------
## If this fails, write code using if(), %in%, and names() to rename any
## mismatched column names reproducibly every time you render from the raw data
required_cols <- c("trialType", "block", "rt", "response", "trial_index",
"time_elapsed", "word", "expectedCategory",
"expectedCategoryAsDisplayed", "leftCategory", "rightCategory",
"correct", "question_order")
if ("trial_type" %in% names(df)) {
names(df)[names(df) == "trial_type"] <- "trialType"
}
# Bug 2. Fixed a wrong column name from trial_type to trialType
# Don't refactor to ifelse() - later when doing the AI comparison, you can ask why
if (!all(required_cols %in% names(df))) {
stop(
paste(
"Input data frame missing required columns in",
sub("\\.csv$", "", basename(file_name)),
"\nExpected:",
paste(required_cols, collapse = ", "),
"\nFound:",
paste(names(df), collapse = ", ")
)
)
}
#### Extract subject_id from file name ---------------------------------------
id <- regmatches(file_name, regexpr("sub-[0-9]{3}", file_name))
subject_id <- ifelse(length(id) == 1, id, NA_character_)
rm(id)
if (is.na(subject_id)) {
warning("Filename does not contain a valid 'sub-###' pattern: ", file_name)
}
#### Subset questionnaire vs. task -------------------------------------------
task_df <- df[df$trialType == "iat", , drop = FALSE]
questionnaire_df <- df[df$trialType == "Questionnaire", , drop = FALSE]
# Bug 1. fixed the typo in "questionnaire" to "Questionnaire"
if (nrow(questionnaire_df) != 1) {
warning("Empty 'questionnaire_df' where data expected. In future steps, 'score_questionnaire' will not run correctly.")
}
#### Calculate Behavior & Questionnaire Scores -------------------------------
behavior <- summarize_behavior(task_df)
anxiety_score <- score_questionnaire(questionnaire_df$response)
#### Save participant summary ------------------------------------------------
## Ensure output directory is created
dir.create(
here::here("data", "cleaned", "participants"),
recursive = TRUE,
showWarnings = FALSE
)
## Combine into a single-row participant summary
df_clean <- data.frame(
subject_id = subject_id,
anxiety_score = anxiety_score,
congruent_mean = behavior["congruent_mean"],
incongruent_mean = behavior["incongruent_mean"],
congruent_accuracy = behavior["congruent_accuracy"],
incongruent_accuracy = behavior["incongruent_accuracy"],
d_score = behavior["d_score"],
row.names = NULL
)
## Save summary CSV to cleaned/participants
write.csv(
df_clean,
here::here("data", "cleaned", "participants", paste0(subject_id, "_cleaned.csv")),
row.names = FALSE
)
#### Return output -----------------------------------------------------------
stopifnot(nrow(df_clean) == 1)  # one row per participant
return(df_clean)
}
participant_wide <- build_participant_wide()
import_and_process <- function(file_name) {
#### Read participant CSV ----------------------------------------------------
df <- read.csv(
here::here("data", "raw", file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
## If you see an error "cannot open the connection", it usually means that R cannot find something where it's looking. Check your paths, files, and file_name. Remember where file_name comes from.
#### Check expected columns ----------------------------
## If this fails, write code using if(), %in%, and names() to rename any
## mismatched column names reproducibly every time you render from the raw data
required_cols <- c("trialType", "block", "rt", "response", "trial_index",
"time_elapsed", "word", "expectedCategory",
"expectedCategoryAsDisplayed", "leftCategory", "rightCategory",
"correct", "question_order")
if ("trial_type" %in% names(df)) {
names(df)[names(df) == "trial_type"] <- "trialType"
}
# Bug 2. Some columns are misnamed, so I created a function for renaming columns
extr_name <- function(x) {
x <- tolower(x)
x <- gsub("[^a-z]","",x)
return(x)
}
for (i in seq_along(names(df))) {
if (grepl("trialtype", extr_name(names(df[i])))) {
names(df)[i] <- "trialType"
} else if (grepl("categorydisplayed", extr_name(i))) {
names(df)[i] <- "expectedCategoryAsDisplayed"
}
}
# Don't refactor to ifelse() - later when doing the AI comparison, you can ask why
if (!all(required_cols %in% names(df))) {
stop(
paste(
"Input data frame missing required columns in",
sub("\\.csv$", "", basename(file_name)),
"\nExpected:",
paste(required_cols, collapse = ", "),
"\nFound:",
paste(names(df), collapse = ", ")
)
)
}
#### Extract subject_id from file name ---------------------------------------
id <- regmatches(file_name, regexpr("sub-[0-9]{3}", file_name))
subject_id <- ifelse(length(id) == 1, id, NA_character_)
rm(id)
if (is.na(subject_id)) {
warning("Filename does not contain a valid 'sub-###' pattern: ", file_name)
}
#### Subset questionnaire vs. task -------------------------------------------
task_df <- df[df$trialType == "iat", , drop = FALSE]
questionnaire_df <- df[df$trialType == "Questionnaire", , drop = FALSE]
# Bug 1. fixed the typo in "questionnaire" to "Questionnaire"
if (nrow(questionnaire_df) != 1) {
warning("Empty 'questionnaire_df' where data expected. In future steps, 'score_questionnaire' will not run correctly.")
}
#### Calculate Behavior & Questionnaire Scores -------------------------------
behavior <- summarize_behavior(task_df)
anxiety_score <- score_questionnaire(questionnaire_df$response)
#### Save participant summary ------------------------------------------------
## Ensure output directory is created
dir.create(
here::here("data", "cleaned", "participants"),
recursive = TRUE,
showWarnings = FALSE
)
## Combine into a single-row participant summary
df_clean <- data.frame(
subject_id = subject_id,
anxiety_score = anxiety_score,
congruent_mean = behavior["congruent_mean"],
incongruent_mean = behavior["incongruent_mean"],
congruent_accuracy = behavior["congruent_accuracy"],
incongruent_accuracy = behavior["incongruent_accuracy"],
d_score = behavior["d_score"],
row.names = NULL
)
## Save summary CSV to cleaned/participants
write.csv(
df_clean,
here::here("data", "cleaned", "participants", paste0(subject_id, "_cleaned.csv")),
row.names = FALSE
)
#### Return output -----------------------------------------------------------
stopifnot(nrow(df_clean) == 1)  # one row per participant
return(df_clean)
}
participant_wide <- build_participant_wide()
import_and_process <- function(file_name) {
#### Read participant CSV ----------------------------------------------------
df <- read.csv(
here::here("data", "raw", file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
## If you see an error "cannot open the connection", it usually means that R cannot find something where it's looking. Check your paths, files, and file_name. Remember where file_name comes from.
#### Check expected columns ----------------------------
## If this fails, write code using if(), %in%, and names() to rename any
## mismatched column names reproducibly every time you render from the raw data
required_cols <- c("trialType", "block", "rt", "response", "trial_index",
"time_elapsed", "word", "expectedCategory",
"expectedCategoryAsDisplayed", "leftCategory", "rightCategory",
"correct", "question_order")
if ("trial_type" %in% names(df)) {
names(df)[names(df) == "trial_type"] <- "trialType"
}
# Bug 2. Some columns are misnamed, so I created a function for renaming columns
extr_name <- function(x) {
x <- tolower(x)
x <- gsub("[^a-z]","",x)
return(x)
}
for (i in seq_along(names(df))) {
if (grepl("trialtype", extr_name(names(df[i])))) {
names(df)[i] <- "trialType"
} else if (grepl("categorydisplayed", extr_name(names(df[i])))){
names(df)[i] <- "expectedCategoryAsDisplayed"
}
}
# Don't refactor to ifelse() - later when doing the AI comparison, you can ask why
if (!all(required_cols %in% names(df))) {
stop(
paste(
"Input data frame missing required columns in",
sub("\\.csv$", "", basename(file_name)),
"\nExpected:",
paste(required_cols, collapse = ", "),
"\nFound:",
paste(names(df), collapse = ", ")
)
)
}
#### Extract subject_id from file name ---------------------------------------
id <- regmatches(file_name, regexpr("sub-[0-9]{3}", file_name))
subject_id <- ifelse(length(id) == 1, id, NA_character_)
rm(id)
if (is.na(subject_id)) {
warning("Filename does not contain a valid 'sub-###' pattern: ", file_name)
}
#### Subset questionnaire vs. task -------------------------------------------
task_df <- df[df$trialType == "iat", , drop = FALSE]
questionnaire_df <- df[df$trialType == "Questionnaire", , drop = FALSE]
# Bug 1. fixed the typo in "questionnaire" to "Questionnaire"
if (nrow(questionnaire_df) != 1) {
warning("Empty 'questionnaire_df' where data expected. In future steps, 'score_questionnaire' will not run correctly.")
}
#### Calculate Behavior & Questionnaire Scores -------------------------------
behavior <- summarize_behavior(task_df)
anxiety_score <- score_questionnaire(questionnaire_df$response)
#### Save participant summary ------------------------------------------------
## Ensure output directory is created
dir.create(
here::here("data", "cleaned", "participants"),
recursive = TRUE,
showWarnings = FALSE
)
## Combine into a single-row participant summary
df_clean <- data.frame(
subject_id = subject_id,
anxiety_score = anxiety_score,
congruent_mean = behavior["congruent_mean"],
incongruent_mean = behavior["incongruent_mean"],
congruent_accuracy = behavior["congruent_accuracy"],
incongruent_accuracy = behavior["incongruent_accuracy"],
d_score = behavior["d_score"],
row.names = NULL
)
## Save summary CSV to cleaned/participants
write.csv(
df_clean,
here::here("data", "cleaned", "participants", paste0(subject_id, "_cleaned.csv")),
row.names = FALSE
)
#### Return output -----------------------------------------------------------
stopifnot(nrow(df_clean) == 1)  # one row per participant
return(df_clean)
}
participant_wide <- build_participant_wide()
View(participant_wide)
nrow(participant_wide)
head(participant_wide, 6)
tail(participant_wide, 6)
cols <- c("congruent_mean", "incongruent_mean",
"congruent_accuracy", "incongruent_accuracy",
"d_score", "anxiety_score")
participant_wide[, cols] |>
is.na() |>
colSums() |>
(\(x) {
data.frame(
variable  = names(x),
n_missing = unname(x),
expected  = 0
)
})() |>
print()
round(range(participant_wide$congruent_mean, na.rm = TRUE), 1)[2]
round(range(participant_wide$congruent_mean, na.rm = TRUE), 1)[1]
cols <- c("congruent_mean",
"incongruent_mean",
"congruent_accuracy",
"incongruent_accuracy",
"d_score",
"anxiety_score")
df_vals <- participant_wide[, cols]
## Calculate Means for all measures
means <- colMeans(df_vals, na.rm = TRUE)
## Calculate Standard Deviations for all measures
sds <- apply(df_vals, 2, sd, na.rm = TRUE)
sda
sds
## Calculate Standard Errors for all measures
ses <- apply(
df_vals,
2,
function(x) sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x)))
)
## RT paired t-test
rt_ttest <- t.test(participant_wide$congruent_mean,
participant_wide$incongruent_mean,
paired = TRUE)
## Accuracy paired t-test
acc_ttest <- t.test(participant_wide$congruent_accuracy,
participant_wide$incongruent_accuracy,
paired = TRUE)
View(participant_wide)
## TODO: Use ggplot2 to re-create:
## (1) histogram of D-scores and
d_plot <- ggplot(participant_wide, aes(d_score)) +
geom_histogram()
d_plot
## TODO: Use ggplot2 to re-create:
## (1) histogram of D-scores and
d_plot <- ggplot(participant_wide, aes(d_score)) +
geom_histogram() +
theme_minimal()
## TODO: Use ggplot2 to re-create:
## (1) histogram of D-scores and
d_plot <- ggplot(participant_wide, aes(d_score)) +
geom_histogram() +
theme_minimal()
d_plot
ggplot(participant_wide, aes(d_score)) +
geom_histogram() +
geom_vline(xintercept = c(d_mean,d_mean-d_sd, d_mean+d_sd),
color = c("red", "blue", "red"))+
theme_minimal()
## TODO: Use ggplot2 to re-create:
## (1) histogram of D-scores and
d_mean <- mean(participant_wide$d_score, na.rm = TRUE)
d_sd   <- sd(participant_wide$d_score,  na.rm = TRUE)
ggplot(participant_wide, aes(d_score)) +
geom_histogram() +
geom_vline(xintercept = c(d_mean,d_mean-d_sd, d_mean+d_sd),
color = c("red", "blue", "red"))+
theme_minimal()
ggplot(participant_wide, aes(d_score)) +
geom_histogram() +
geom_vline(xintercept = c(d_mean,d_mean-d_sd, d_mean+d_sd),
color = c("darkblue", "darkred", "darkred")) +
labs(title = "Distribution of D scores", xlab = "D score", ylab = "Count")
theme_minimal()
d_plot <- ggplot(participant_wide, aes(d_score)) +
geom_histogram() +
geom_vline(xintercept = c(d_mean,d_mean-d_sd, d_mean+d_sd),
color = c("darkblue", "darkred", "darkred")) +
labs(title = "Distribution of D scores", xlab = "D score", ylab = "Count") +
theme_minimal()
d_plot
d_plot <- ggplot(participant_wide, aes(d_score)) +
geom_histogram() +
geom_vline(xintercept = c(d_mean,d_mean-d_sd, d_mean+d_sd),
color = c("darkblue", "darkred", "darkred")) +
labs(title = "Distribution of D scores", x = "D score", ylab = "Count") +
theme_minimal()
d_plot
ses
plot_df <- data.frame(category = c("congruent", "incongruent"),
mean_values = c(means["congruent_mean"],
means["incongruent_mean"]))
plot_df <- data.frame(category = c("congruent", "incongruent"),
mean_values = c(means["congruent_mean"],
means["incongruent_mean"]),
se_values = c(ses["congruent_mean"],
ses["incongruent_mean"]))
ggplot(plot_df, aes(category, mean_values)) +
geom_bar()
View(plot_df)
## (2) bar plot of mean RTs. Include standard error bars.
plot_df <- data.frame(category = c("congruent", "incongruent"),
mean_values = c(means["congruent_mean"],
means["incongruent_mean"]),
se_values = c(ses["congruent_mean"],
ses["incongruent_mean"]),
row.names = FALSE)
## (2) bar plot of mean RTs. Include standard error bars.
plot_df <- data.frame(category = c("congruent", "incongruent"),
mean_values = c(means["congruent_mean"],
means["incongruent_mean"]),
se_values = c(ses["congruent_mean"],
ses["incongruent_mean"]),
row.names = NULL)
ggplot(plot_df, aes(category, mean_values)) +
geom_bar()
ggplot(plot_df, aes(category, mean_values)) +
geom_col()
ggplot(plot_df, aes(category, mean_values)) +
geom_col() +
geom_errorbar(aes(ymin = mean_values - se_values,
ymax = mean_values + se_values))
ggplot(plot_df, aes(category, mean_values)) +
geom_col() +
geom_errorbar(aes(ymin = mean_values - se_values,
ymax = mean_values + se_values), width = 0.2)
ggplot(plot_df, aes(category, mean_values)) +
geom_col() +
geom_errorbar(aes(ymin = mean_values - 2*se_values,
ymax = mean_values + 2*se_values), width = 0.2)
ggplot(plot_df, aes(category, mean_values)) +
geom_col() +
geom_errorbar(aes(ymin = mean_values - 2*se_values,
ymax = mean_values + 2*se_values), width = 0.2, col="steelblue")
ggplot(plot_df, aes(category, mean_values)) +
geom_col(fill = "grey") +
geom_errorbar(aes(ymin = mean_values - 2*se_values,
ymax = mean_values + 2*se_values), width = 0.2, col="steelblue")
ggplot(plot_df, aes(category, mean_values)) +
geom_col(fill = "grey") +
geom_errorbar(aes(ymin = mean_values - 2*se_values,
ymax = mean_values + 2*se_values), width = 0.2, col="steelblue") +
theme_minimal()
ggplot(plot_df, aes(category, mean_values)) +
geom_col(fill = "grey") +
geom_errorbar(aes(ymin = mean_values - 2*se_values,
ymax = mean_values + 2*se_values), width = 0.2, col="steelblue") +
labs(title = "Mean RT on congruent and incongruent trials", x = "Mean")
print(d_plot)
cor_plot <- ggplot(participant_wide, aes(anxiety_score, d_score)) +
geom_point()
print(cor_plot)
cor_plot <- ggplot(participant_wide, aes(anxiety_score, d_score)) +
geom_point() +
geom_smooth()
print(cor_plot)
cor_plot <- ggplot(participant_wide, aes(anxiety_score, d_score)) +
geom_point() +
geom_smoot(method = "lm")
print(cor_plot)
cor_plot <- ggplot(participant_wide, aes(anxiety_score, d_score)) +
geom_point() +
geom_smoot(method = "lm")
cor_plot <- ggplot(participant_wide, aes(anxiety_score, d_score)) +
geom_point() +
geom_smooth(method = "lm")
print(cor_plot)
cor_plot <- ggplot(participant_wide, aes(anxiety_score, d_score)) +
geom_point() +
geom_smooth(method = "lm") +
labs(title = "Relationship between anxiety and D scores",
x = "Anxiety",
y = "D score")
theme_minimal()
print(cor_plot)
cor_plot <- ggplot(participant_wide, aes(anxiety_score, d_score)) +
geom_point() +
geom_smooth(method = "lm", color = "darkred") +
labs(title = "Relationship between anxiety and D scores",
x = "Anxiety",
y = "D score") +
theme_minimal()
print(cor_plot)
## Save participant_wide data frame
write.csv(participant_wide, here::here("outputs", "tables", "participant_wide.csv"), row.names = FALSE)
ensure_dir <- function(path) if (!dir.exists(path)) dir.create(path, recursive = TRUE, showWarnings = FALSE)
ensure_dir(file.path(here::here("data","raw")))
ensure_dir(file.path(here::here("data","cleaned")))
ensure_dir(file.path(here::here("outputs","tables")))
ensure_dir(file.path(here::here("outputs","plots")))
ensure_dir <- function(path) if (!dir.exists(path)) dir.create(path, recursive = TRUE, showWarnings = FALSE)
ensure_dir(file.path(here::here("data","raw")))
ensure_dir(file.path(here::here("data","cleaned")))
ensure_dir(file.path(here::here("outputs","tables")))
ensure_dir(file.path(here::here("outputs","plots")))
save(d_plot, file = "d_plot.rda")
save(d_plot, file = here::here("outputs","plots", "d_plot.rda"))
## Remember that the plots do **not** save automatically. Use `ggplot2::ggsave()` to save each plot, for example:
## ggsave("my_plot.png", my_plot_object, path = here::here("outputs", "plots"))
ggsave("cor_plot.png", cor_plot, path = here::here("outputs","plots"))
View(task_df)
participant_wide <- build_participant_wide()
source(here::here("scripts/calculate_iat_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
participant_wide <- build_participant_wide()
