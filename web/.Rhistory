geom_point()
library(tidyverse)
dat %>%
ggplot(aes(Raven, perf1)) +
geom_point()
dat %>%
ggplot(aes(Raven, perf2)) +
geom_point()
dat %>%
ggplot(aes(Raven, perf3)) +
geom_point()
dat %>%
ggplot(aes(perf3, IDP12)) +
geom_point()
dat %>%
ggplot(aes(perf2, IDP13)) +
geom_point()
dat %>%
ggplot(aes(BAS, IDP13)) +
geom_point()
dat %>%
ggplot(aes(BAS_reward, IDP13)) +
geom_point()
dat %>%
ggplot(aes(BAS_drive, IDP13)) +
geom_point()
dat %>%
ggplot(aes(BAS_drive, IDP12)) +
geom_point()
dat %>%
ggplot(aes(BAS_drive, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "blue")
dat %>%
ggplot(aes(BAS_drive, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue")
dat %>%
ggplot(aes(BAS_reward, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue")
dat %>%
ggplot(aes(Raven, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue")
dat %>%
ggplot(aes(perf1, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue")
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue")
dat %>%
ggplot(aes(perf3, IDP13)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue")
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue")
dat %>%
ggplot(aes(perf1, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue")
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue")
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(x="Performance on a working memory task", y="willingness to invest cognitive effort in the task")
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
theme_set(theme_minimal())
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(title="d", x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(title="Willingness to invest effort is only moderately predicted by ability", x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
p <- dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(title="Willingness to invest effort is only moderately predicted by ability", x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
p
print(p)
dat %>%
ggplot(aes(perf2, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(title="Willingness to invest effort is only moderately predicted by ability", x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
dat %>%
ggplot(aes(SRQ_intri, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(title="Willingness to invest effort is only moderately predicted by ability", x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
dat %>%
ggplot(aes(SRQ_intri, IDP12)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(title="Willingness to invest effort is only moderately predicted by ability", x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
dat %>%
ggplot(aes(SRQ_intri, IDP13)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(title="Willingness to invest effort is only moderately predicted by ability", x="Performance on a working memory task", y="Willingness to invest cognitive effort in the task")
dat %>%
ggplot(aes(SRQ_intri, IDP13)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(title="Willingness to invest effort in a cognitive task and intrinsic motivation", x="Self-reported intrinsic motivation", y="Willingness to invest cognitive effort in the task")
dat %>%
ggplot(aes(SRQ_intri, IDP13)) +
geom_point() +
geom_smooth(method = "lm", se = TRUE, color = "darkblue") +
labs(title="Willingness to invest effort in a cognitive task and intrinsic motivation", x="Self-reported intrinsic motivation", y="Willingness to invest cognitive effort in the task")
update.packages()
#  I've set a seed below so that all of your solutions will involve the same numbers.
set.seed(123)
# (1) Generate a vector with 25 random numbers. Give it a descriptive name.
#     Print the vector.
#     Hint: rnorm() function - don't worry about setting the mean or SD
rand_vec <- rnorm(25)
# (1) Generate a vector with 25 random numbers. Give it a descriptive name.
#     Print the vector.
#     Hint: rnorm() function - don't worry about setting the mean or SD
rand_vec <- c(rnorm(25))
class(rand_vec)
type(rand_vec)
rand_vec
rand_vec <- c(2,3)
# (1) Generate a vector with 25 random numbers. Give it a descriptive name.
#     Print the vector.
#     Hint: rnorm() function - don't worry about setting the mean or SD
rand_vec <- c(rnorm(25))
# (1) Generate a vector with 25 random numbers. Give it a descriptive name.
#     Print the vector.
#     Hint: rnorm() function - don't worry about setting the mean or SD
rand_vec <- rnorm(25)
# (1) Generate a vector with 25 random numbers. Give it a descriptive name.
#     Print the vector.
#     Hint: rnorm() function - don't worry about setting the mean or SD
rand_vec <- c(rnorm(25))
#  I've set a seed below so that all of your solutions will involve the same numbers.
set.seed(123)
# (1) Generate a vector with 25 random numbers. Give it a descriptive name.
#     Print the vector.
#     Hint: rnorm() function - don't worry about setting the mean or SD
rand_vec <- rnorm(25)
rand_vec
#  I've set a seed below so that all of your solutions will involve the same numbers.
set.seed(123)
# (1) Generate a vector with 25 random numbers. Give it a descriptive name.
#     Print the vector.
#     Hint: rnorm() function - don't worry about setting the mean or SD
rand_vec <- rnorm(25)
rand_vec
# (2) Convert the vector into a matrix with five rows and five columns.
#     Give the matrix a similarly descriptive name, and print it.
rand_mat <- matrix(rand_vec, nrow=5, ncol=5)
rand_mat
# (3) Multiply every element of the matrix by 100, and round the new
#     values to the second decimal place (using the round() function).
#     Save the result back to the same matrix object and print it again.
rand_mat <- round(rand_mat * 100, 2)
rand_mat
# (4) Swap the first and second columns of the matrix. Print the matrix again.
rand_mat <- rand_mat[,c(2,1,3,4)]
rand_mat
# (5) Remove the last 2 columns of the matrix and save the result as
#     a data frame called daily.winnings. Print the data frame.
daily.winnings <- data.frame(rand_mat[,1:3])
daily.winnings
# (6) Rename the columns using the variable names "Bellagio", "Mirage", and "MGM_Grand"
colnames(daily.winnings) <- c("Bellagio", "Mirage", "MGM_Grand")
daily.winnings
# (7) Remove (replace with NA) the fourth day's winnings at the Bellagio.
#     Then calculate and print the average daily winnings at the Bellagio.
#     Hint: You need to use an extra argument with mean().
daily.winnings[1,4] <- NA
mean(daily.winnings$Bellagio, na.rm = TRUE)
daily.winnings
# (7) Remove (replace with NA) the fourth day's winnings at the Bellagio.
#     Then calculate and print the average daily winnings at the Bellagio.
#     Hint: You need to use an extra argument with mean().
daily.winnings[1,4] <- NA
daily.winnings
# (7) Remove (replace with NA) the fourth day's winnings at the Bellagio.
#     Then calculate and print the average daily winnings at the Bellagio.
#     Hint: You need to use an extra argument with mean().
daily.winnings[4,1] <- NA
daily.winnings
# (5) Remove the last 2 columns of the matrix and save the result as
#     a data frame called daily.winnings. Print the data frame.
daily.winnings <- data.frame(rand_mat[,1:3])
daily.winnings
# (6) Rename the columns using the variable names "Bellagio", "Mirage", and "MGM_Grand"
colnames(daily.winnings) <- c("Bellagio", "Mirage", "MGM_Grand")
daily.winnings
# (7) Remove (replace with NA) the fourth day's winnings at the Bellagio.
#     Then calculate and print the average daily winnings at the Bellagio.
#     Hint: You need to use an extra argument with mean().
daily.winnings[4,1] <- NA
daily.winnings
mean(daily.winnings$Bellagio, na.rm = TRUE)
# (8) Add a new variable to daily.winnings: a factor called "Game".
#     The factor should have the levels "blackjack" and "poker".
#     The values of "Game" should indicate that blackjack was played
#     on days 2, 4, and 5, and that poker was played on days 1 and 3.
#     Print daily.winnings again, and print its structure.
daily.winnings$Game <- factor(c("Poker", "Blackjack", "Poker", "Blackjack",
"Blackjack"), levels=c("Blackjack", "Poker"))
daily.winnings
str(daily.winnings)
?subset
# (9) Retrieve only the poker winnings and save them to a new data frame (name it
#     something descriptive). Calculate the total overall poker winnings.
poker_winnings <- subset(daily.winnings,Game=="Poker")
poker_winnings
# (9) Retrieve only the poker winnings and save them to a new data frame (name it
#     something descriptive). Calculate the total overall poker winnings.
poker_winnings <- subset(daily.winnings, Game=="Poker", select=-Game)
poker_winnings
sum(poker_winnings)
# (10) Take the first vector, matrix, and data frame that you created
#      and put them all into a list called PS1.vars.
PS1.vars <- list(rand_vec, rand_mat, poker_winnings)
#      Perform the following operations on PS1.vars:
#      (a) Extract the fourth element of the first element of PS1.vars.
#          Save it to the variable a.
a <- PS1.vars[1][[4]]
PS1.vars[1]
#      Perform the following operations on PS1.vars:
#      (a) Extract the fourth element of the first element of PS1.vars.
#          Save it to the variable a.
a <- PS1.vars[[1]][4]
a
View(PS1.vars)
#      (b) Extract the element at row 4, column 2 from the third element of PS1.vars.
#          Save it to the variable b.
b <- PS1.vars[[3]][4,2]
b
PS1.vars[[3]]
# (10) Take the first vector, matrix, and data frame that you created
#      and put them all into a list called PS1.vars.
PS1.vars <- list(rand_vec, rand_mat, daily_winnings)
# (10) Take the first vector, matrix, and data frame that you created
#      and put them all into a list called PS1.vars.
PS1.vars <- list(rand_vec, rand_mat, daily.winnings)
#      Perform the following operations on PS1.vars:
#      (a) Extract the fourth element of the first element of PS1.vars.
#          Save it to the variable a.
a <- PS1.vars[[1]][4]
#      (b) Extract the element at row 4, column 2 from the third element of PS1.vars.
#          Save it to the variable b.
b <- PS1.vars[[3]][4,2]
b
PS1.vars
#      (c) Extract the second through fourth elements of the third column of the matrix from PS1.vars,
#          and calculate the standard deviation of the resultant values. (Hint: sd() function).
#          Save the standard deviation value to the variable c.
c <- sd(PS1.vars[[2]][2:4,3])
c
#      (d) Create a vector called abc containing the values from (a), (b), and (c).
#          Add abc as a new element of PS1.vars. Print PS1.vars.
abc <- c(a, b, c)
PS1.vars[[4]] <- abc
PS1.vars
set.seed(2025)
library(dplyr)
# ----- 1. PARAMETERS -----
# Urn discriminabilities (probability of drawing BLUE from urn A vs urn B)
discriminabilities <- list(
high   = c(theta_A = 0.85, theta_B = 0.15),
medium = c(theta_A = 0.70, theta_B = 0.30),
low    = c(theta_A = 0.60, theta_B = 0.40)
)
R0 <- 5.00           # initial reward for correct guess
decay_amount <- 0.20 # reward decreases by $0.20 per bead drawn
sure_fracs <- c(0.3, 0.5, 0.7)  # sure payout as fraction of R0
max_draws <- 20
trials_per_condition <- 20   # how many trials per condition
# ----- 2. HELPER FUNCTIONS -----
# Reward schedule (linear decay)
reward_schedule <- function(R0, decay_amount, max_draws = 20) {
t <- 0:max_draws
R_t <- pmax(0, R0 - decay_amount * t)
data.frame(draw = t, reward = R_t)
}
# Generate bead sequence for one trial
generate_beads <- function(theta_A, theta_B, urn_chosen, max_draws) {
theta <- ifelse(urn_chosen == "A", theta_A, theta_B)
draws <- ifelse(runif(max_draws) < theta, "blue", "red")
paste(draws, collapse = ",")
}
# ----- 3. BUILD TRIAL GRID -----
trial_list <- expand.grid(
discrim = names(discriminabilities),
sure_frac = sure_fracs,
stringsAsFactors = FALSE
) %>%
slice(rep(1:n(), each = trials_per_condition)) %>%
mutate(
trial_id = row_number(),
R0 = R0,
decay_amount = decay_amount,
sure_amount = sure_frac * R0,
urn_chosen = sample(c("A", "B"), size = n(), replace = TRUE),
theta_A = sapply(discrim, function(x) discriminabilities[[x]]["theta_A"]),
theta_B = sapply(discrim, function(x) discriminabilities[[x]]["theta_B"]),
bead_seq = mapply(generate_beads,
theta_A = theta_A,
theta_B = theta_B,
urn_chosen = urn_chosen,
MoreArgs = list(max_draws = max_draws))
)
# Add reward schedule
trial_list <- trial_list %>%
rowwise() %>%
mutate(reward_schedule = list(reward_schedule(R0, decay_amount, max_draws))) %>%
ungroup()
# Flatten reward schedule into columns reward_t0 ... reward_tN
reward_flat <- do.call(rbind, lapply(trial_list$reward_schedule, function(df) {
as.data.frame(t(df$reward))
}))
colnames(reward_flat) <- paste0("reward_t", 0:max_draws)
trial_out <- bind_cols(trial_list %>% select(-reward_schedule), reward_flat)
# ----- 4. SAVE TRIALS -----
write.csv(trial_out, "beads_task_trials_simple.csv", row.names = FALSE)
message("✅ Saved trial spreadsheet to beads_task_trials_simple.csv")
# Quick sanity check
head(trial_out)
set.seed(2025)
library(dplyr)
# ----- 1. PARAMETERS -----
# Urn discriminabilities (probability of drawing BLUE from urn A vs urn B)
discriminabilities <- list(
high   = c(theta_A = 0.85, theta_B = 0.15),
medium = c(theta_A = 0.70, theta_B = 0.30),
low    = c(theta_A = 0.60, theta_B = 0.40)
)
R0 <- 5.00           # initial reward for correct guess
decay_amount <- 0.20 # reward decreases by $0.20 per bead drawn
sure_fracs <- c(0.3, 0.5, 0.7)  # sure payout as fraction of R0
max_draws <- 20
trials_per_condition <- 20   # how many trials per condition
# ----- 2. HELPER FUNCTIONS -----
# Reward schedule (linear decay)
reward_schedule <- function(R0, decay_amount, max_draws = 20) {
t <- 0:max_draws
R_t <- pmax(0, R0 - decay_amount * t)
data.frame(draw = t, reward = R_t)
}
# Generate bead sequence for one trial
generate_beads <- function(theta_A, theta_B, urn_chosen, max_draws) {
theta <- ifelse(urn_chosen == "A", theta_A, theta_B)
draws <- ifelse(runif(max_draws) < theta, "blue", "red")
paste(draws, collapse = ",")
}
# ----- 3. BUILD TRIAL GRID -----
trial_list <- expand.grid(
discrim = names(discriminabilities),
sure_frac = sure_fracs,
stringsAsFactors = FALSE
) %>%
slice(rep(1:n(), each = trials_per_condition)) %>%
mutate(
trial_id = row_number(),
R0 = R0,
decay_amount = decay_amount,
sure_amount = sure_frac * R0,
urn_chosen = sample(c("A", "B"), size = n(), replace = TRUE),
theta_A = sapply(discrim, function(x) discriminabilities[[x]]["theta_A"]),
theta_B = sapply(discrim, function(x) discriminabilities[[x]]["theta_B"]),
bead_seq = mapply(generate_beads,
theta_A = theta_A,
theta_B = theta_B,
urn_chosen = urn_chosen,
MoreArgs = list(max_draws = max_draws))
)
# Add reward schedule
trial_list <- trial_list %>%
rowwise() %>%
mutate(reward_schedule = list(reward_schedule(R0, decay_amount, max_draws))) %>%
ungroup()
# Flatten reward schedule into columns reward_t0 ... reward_tN
reward_flat <- do.call(rbind, lapply(trial_list$reward_schedule, function(df) {
as.data.frame(t(df$reward))
}))
colnames(reward_flat) <- paste0("reward_t", 0:max_draws)
trial_out <- bind_cols(trial_list %>% select(-reward_schedule), reward_flat)
# ----- 4. SAVE TRIALS -----
write.csv(trial_out, "beads_task_trials_simple.csv", row.names = FALSE)
message("✅ Saved trial spreadsheet to beads_task_trials_simple.csv")
# Quick sanity check
head(trial_out)
getwd()
# ==== Modified Beads Task: Posterior and Expected Value ====
set.seed(2025)
library(dplyr)
# ----- 1. PARAMETERS -----
discriminabilities <- list(
high   = c(theta_A = 0.85, theta_B = 0.15),
medium = c(theta_A = 0.70, theta_B = 0.30),
low    = c(theta_A = 0.60, theta_B = 0.40)
)
R0 <- 5.00
decay <- 0.20
sure_frac <- 0.5
max_draws <- 20
# ----- 2. HELPER FUNCTIONS -----
# Generate bead sequence for one trial
generate_beads <- function(theta_A, theta_B, urn_chosen, max_draws) {
theta <- ifelse(urn_chosen == "A", theta_A, theta_B)
draws <- ifelse(runif(max_draws) < theta, "blue", "red")
return(draws)
}
# Compute posterior after each bead
compute_posteriors <- function(draws, theta_A, theta_B) {
n <- length(draws)
pA <- numeric(n)
pB <- numeric(n)
prior_A <- 0.5
prior_B <- 0.5
for (t in 1:n) {
# likelihood of this draw given urn
like_A <- ifelse(draws[t] == "blue", theta_A, 1 - theta_A)
like_B <- ifelse(draws[t] == "blue", theta_B, 1 - theta_B)
# posterior update
numer_A <- prior_A * like_A
numer_B <- prior_B * like_B
denom <- numer_A + numer_B
post_A <- numer_A / denom
post_B <- numer_B / denom
pA[t] <- post_A
pB[t] <- post_B
# update prior for next draw
prior_A <- post_A
prior_B <- post_B
}
return(data.frame(draw_num = 1:n, pA = pA, pB = pB))
}
# Reward decay schedule
reward_schedule <- function(R0, decay, max_draws) {
R_t <- pmax(0, R0 - decay * (0:max_draws))
return(R_t)
}
# ----- 3. SIMULATE ONE SEQUENCE PER DISCRIMINABILITY -----
trial_data <- list()
for (disc in names(discriminabilities)) {
params <- discriminabilities[[disc]]
urn_true <- sample(c("A", "B"), 1)
draws <- generate_beads(params["theta_A"], params["theta_B"], urn_true, max_draws)
posts <- compute_posteriors(draws, params["theta_A"], params["theta_B"])
reward_t <- reward_schedule(R0, decay, max_draws)
sure_amt <- sure_frac * R0
df <- posts %>%
mutate(
discrim = disc,
urn_true = urn_true,
draw_color = draws,
reward = reward_t[draw_num + 1],
EV_guess = pmax(pA, pB) * reward,
EV_sure = sure_amt,
advantage_guess = EV_guess - EV_sure
)
trial_data[[disc]] <- df
}
# ----- 4. COMBINE AND SAVE -----
trial_df <- bind_rows(trial_data)
write.csv(trial_df, "beads_posterior_EV.csv", row.names = FALSE)
message("✅ Saved trial-level posterior & EV data to beads_posterior_EV.csv")
# Preview
head(trial_df)
setwd("/Users/garthcoombs/Desktop/psy1903/web/") # Will need to update to your path
setwd("\Users\mayak\Desktop\psy1903\web")
setwd("/Users/mayak/Desktop/psy1903/web")
dir.create("week10_taskset")
dir.create("week10_taskset/data")
dir.create("week10_taskset/data/raw")
dir.create("week10_taskset/data/cleaned")
dir.create("week10_taskset/scripts")
dir.create("week10_taskset/output")
dir.create("week10_taskset/output/plots")
dir.create("week10_taskset/output/tables")
dir.create("week10_taskset/reports")
